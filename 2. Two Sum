Brute force: Check for every element twice using two loops. O(N2)

Better: Using Hashing
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
     map<int, int> mp;
     for(int i=0; i<nums.size(); i++){
        int a = nums[i];
        int more = target - a;
        if(mp.find(more) != mp.end()){
            return {mp[more], i};
        }
        mp[a] = i;
     }   
     return {-1,-1};
    }
};        

Best: Two pointer approach, only optimal if we have to return yes or no !
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
     int left = 0, right = nums.size()-1;
     while(left < right){
        int sum = nums[left] = nums[right];
        if(sum == target){
            return "YES";
        }
        else if (sum < target) left ++;
        else right --;
    }
    return "NO";
}; 



